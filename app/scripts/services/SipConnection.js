/*
*Copyright (c) 2013 Thomas Falkenberg.
*All rights reserved. This program and the accompanying materials
*are made available under the terms of the GNU Public License v3.0
*which accompanies this distribution, and is available at
*http://www.gnu.org/licenses/gpl.html
*
*Contributors:
*    Thomas Falkenberg - initial API and implementation
*    Deutsche Telekom AG- Telekom Laboratories Darmstadt
*/

// Generated by CoffeeScript 1.3.3
/*global define
*/

define(['services/services','services/WebSocketService','services/sharedScope','services/Registration'], function(services) {
  'use strict';
  return services.factory('SipConnection', [
    	'$rootScope','WebSocketService','Registration','sharedScope',function($rootScope,WebSocketService,Registration,sharedScope){
    		
    		function SipConnection() {
    			
    			var that =this;
    				sharedScope.Registration=Registration;
    				
    				this.transport ="ws";
    				try {
    					sharedScope.createRegistration().transport=this.transport;
					} catch (e) {
						// TODO: handle exception
						sharedScope.error=e; log("error: "+e);
						throw e;
					}
    				sharedScope.createRegistration().transport=this.transport;
    				
    				this.listen_ip = 'r' + Math.floor(Math.random() * 10000000000) + ".invalid";
    			  
    			    this.stack=null;
    			    
    			    this.outbound_proxy_address ='192.168.178.40:10060';
    			    this.websocket_path = "/ws";
    			    this.socket = new WebSocketService(this.outbound_proxy_address,this.websocket_path);
    			    
    			    
    			    // properties in register
    			  
    			   
    			    this.local_aor = function() {
    			    	try {
    			    		return sharedScope.createRegistration().local_aor();
						} catch (e) {
							// TODO: handle exception
							sharedScope.error=e; log("error: "+e);

							throw e;
							return "";
						}
						
    					
    				};
    			    
    			    this.has_audio = true;
    			    this.has_tones = false;
    			    this.has_video = true;
    			    this.has_text = false;
    			    this.has_location = false;
    			    this.location = null;
    			    
    			    
    			    
    			    // private attributes
    			    
//    			    this.network_type = "WebRTC";
    			    this.listen_ip="fritz.box";
    			    this._listen_port = 5060;
    			    
    			    // SIP headers
    			    this.user_agent = "WebRTC";
    			    this.server = this.user_agent;
    			
    			    
    			    this.webrtc_stun = "STUN stun.l.google.com:19302";
    			    
    			    // SIP requirements for websocket
    			    this._instance_id = "";
    			    this._gruu = "";
    			    
    				
    				
    				this.initialize= function() {
    					
    					var transport = new sip.TransportInfo("df7jal23ls0d.invalid", null, that.transport, that.transport == "tls", that.transport != "udp", that.transport != "udp");
    					that.stack= new sip.Stack(that,transport);
    					try {
 							sharedScope.createRegistration().stack=that.stack;
 						} catch (e) {
 							// TODO: handle exception
 							sharedScope.error=e; log("error: "+e);
 							throw e;
 						}

    				};
    				this.reset=function(){
    					 try {
							sharedScope.createRegistration().reset();
						} catch (e) {
							// TODO: handle exception
							sharedScope.error=e; log("error: "+e);
							throw e;
						}
    				};
    				
    				this.connect = function() {
    					that.register();
    				};
    				
    				this.receivedResponse= function(ua, response, stack) {
    				    var method = ua.request.method;
    				    log("received Response: " +method+response);
    				    if (method == 'REGISTER') {
    				    	try {
    							sharedScope.createRegistration().receivedRegisterResponse(ua, response);
    						} catch (e) {
    							// TODO: handle exception
    							sharedScope.error=e; log("error: "+e);
    							throw e;
    						}
    				    }
    				    else if (method == "INVITE") {
    				    	try {
    				    		sharedScope.getCall(ua.remoteParty.uri.toString()).receivedInviteResponse(ua, response);
        				 	} catch (e) {
								// TODO: handle exception
								sharedScope.error=e; log("error: "+e);
								throw e;
							}
    				    }
    				    else if (method == "BYE") {
    				    	try{
    				    		sharedScope.getCall(ua.remoteParty.uri.toString()).receivedByeResponse(ua, response);
    				    	} catch (e) {
								// TODO: handle exception
								sharedScope.error=e; log("error: "+e);
								throw e;
							}
   				    	}
    				    else if (method == "MESSAGE") {
    				    	that.receivedMessageResponse(ua, response);
    				    }
    				    else {
    				        log("ignoring response for method=" + method);
    				    }
    				    $rootScope.$apply();
    				};
    		
    				this.receivedRequest= function(ua, request, stack) {
    				    var method = request.method;
    				    log("received Request:  " + request.method);
    				    switch (method) {
    						case "INVITE":{
    							try{
    								sharedScope.getCall(ua.remoteParty.uri.toString()).receivedInvite(ua, request);
    							} catch (e) {
    								// TODO: handle exception
    								sharedScope.error=e; log("error: "+e);
    								throw e;
    							}
    							break;
    					    }
    						case "BYE": {
    							try{
    								sharedScope.getCall(ua.remoteParty.uri.toString()).receivedBye(ua, request);
    							} catch (e) {
    								// TODO: handle exception
    								sharedScope.error=e; log("error: "+e);
    								throw e;
    							}
    							break;
    					    }
    						case "MESSAGE": {
    					    	that.receivedMessage(ua, request);
    					    	break;
    					    }
    						case "ACK": {
    					    	that.receivedAck(ua, request);
    					    	break;
    						}					
    						default:
    						{
    							log("ignoring received request method=" + method);
    							//if (method != 'ACK') 
    				            ua.sendResponse(ua.createResponse(501, "Not Implemented"));
    							break;
    						}
    					}
    				    $rootScope.$apply();
    				};
    				
    				this.receivedMessage= function(ua, request){
    					
    					
    					 try {
    							var chat = sharedScope.createChat(ua.remoteParty.uri.toString());
    							chat.receivedMessage(ua, request);
    							
    						} catch (e) {
    							log("error:"+ e);
    							sharedScope.error=e;
    							throw e;
    							return;
    						};
    				};
    				this.receivedMessageResponse =function(ua, response) {
        					try {
       							var chat = sharedScope.createChat(ua.remoteParty.uri.toString());
       							chat.receivedMessageResponse(ua, response);
       							
       						} catch (e) {
       							log("error:"+ e);
       							sharedScope.error=e;
       							throw e;
       							return;
       						};
    				};
    				
    				this.send=  function(data, addr, stack) {
    				   //log("=> " + addr[0] + ":" + addr[1] + "\n" + data);
    				    that.socket.send(data, addr);
    				};
    				
    				
    				this.createServer=  function(request, uri, stack) {
    				    log("createServer() for method=" + request.method);
    				    return (request.method != "CANCEL" ? new sip.UserAgent(that.stack, request) : null);
    				};
    			
    				this.cancelled= function() {

    				};
    				this.dialogCreated= function() {

    				};
    				this.authenticate= function(ua, header, stack) {
    					try {
							return sharedScope.createRegistration().authenticate(ua, header, stack);
						} catch (e) {
							// TODO: handle exception
							sharedScope.error=e; log("error: "+e);
							throw e;
							return false;
						}
    				};
    				
    				this.createTimer= function(obj, stack) {
    					return new sip.TimerImpl(obj);
    				};
    				
    				
    				
    				this.receivedAck = function(ua, request) {
    					log("SipConnection.receivedAck");
    					try{
    						sharedScope.getCall(ua.remoteParty.uri.toString()).receivedAck(ua,request);
    					} catch (e) {
							// TODO: handle exception
							sharedScope.e; log("error: "+e);
							throw e;
						}
    				};
    				
    				
//    				this.call =function(to){
//    					log("call: "+to);
//    					try{
//    						sharedScope.getCall("sip:"+to/*+":"+sharedScope.createRegistration().domainPort*/,sharedScope.OUTGOING).start();
//    					} catch (e) {
//							// TODO: handle exception
//							sharedScope.error=e; log("error: "+e);
//							throw e;
//						}
//    				};
//    				
    				
    				this.getRouteHeader = function(username) {
    				    return new sip.Header("<sip:" + this.listen_ip+":"+this._listen_port  + ";lr>", 'Route');
    				};
    			
    				this.register = function() {
    					if (that.socket.state == sharedScope.IDLE) {
    				    	that.socket.state =sharedScope.CREATING;
    				      //  that.register_state= "waiting";
    						    
    				        that.socket.createSocket();
    				    }
    				    else if (that.socket.state == sharedScope.BOUND || that.socket.state == sharedScope.CONNECTED) {
//    					try {
							sharedScope.createRegistration().register();
//						} catch (e) {
//							// TODO: handle exception
//							sharedScope.error=e; log("error: "+e);
//							throw e;
//						}
							}
    				};
    				

    				this.resolve = function(host, type, callback, stack) {
    					log("resolver");
//    				    var resolver = new network.DNSResolver();
//    				    resolver.addEventListener("error", function(event) {
//    				        log("cannot resolve DNS host " + host + " type " + type);
//    				        callback(host, []); 
//    				    });
//    				    resolver.addEventListener("lookup", function(event) {
//    				        log("resolved DNS host " + event.host + " length=" + event.resourceRecords.length);
//    				        callback(host, event.resourceRecords);
//    				    });
//    				    resolver.resolve(host, type);
    				};
    			
    				
    				
    				this.received =function(event){
    				log("<= " + event.srcAddress + ":" + event.srcPort + "\n" + event.data);
    				that.stack.received(event.data, [event.srcAddress, event.srcPort]);
    				};
    				
    				
    				

    			}
    			
    			return SipConnection;
    	}
  ]);
});
