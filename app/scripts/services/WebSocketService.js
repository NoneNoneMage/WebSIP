/*
*Copyright (c) 2013 Thomas Falkenberg.
*All rights reserved. This program and the accompanying materials
*are made available under the terms of the GNU Public License v3.0
*which accompanies this distribution, and is available at
*http://www.gnu.org/licenses/gpl.html
*
*Contributors:
*    Thomas Falkenberg - initial API and implementation
*    Deutsche Telekom AG- Telekom Laboratories Darmstadt
*/

// Generated by CoffeeScript 1.3.3
/*global define
*/

define(['services/services','services/sharedScope'], function(services) {
  'use strict';
  return services.factory('WebSocketService', [
    	'$rootScope','sharedScope',function($rootScope,sharedScope){
    		    		
    		function WebSocketService(out_proxy_addr, ws_path) {
    			this.socket=null;
    			this.state=sharedScope.IDLE;
    			this.websocket_path=ws_path;
    			this.outbound_proxy_address=out_proxy_addr;
    			var that = this;
    			
    			
    			
    			this.send = function(data, addr) {
    			    log("=> " + addr[0] + ":" + addr[1] + "\n" + data);
    			    if(that.state==sharedScope.CONNECTED){
    			    that.socket.send(data);//, addr[0], addr[1]);
    			    }
    			};
    			
    			this.hungup= function() {
    				log("hungup");
    				// end all Calls and remove all Media
    			};
    			this.bin2String = function (blob) {
    				 
    				  var array=new Uint8Array(blob);
    				  var string = new String();
    				    var length = array.byteLength == undefined ? array.length : array.byteLength;
    				    for (var i = 0; i < length; ++i) {
    				        string += String.fromCharCode(array[i] & 0xff);
    				    }
    				    return string;
    				  
    				  
    				};
    				
    			this.onSockData = function(event) {
    				if(typeof(event.data) == 'string'){
    					sharedScope.connection.received(event); //use Callback function???
    				}else{
    					event.data=that.bin2String(event.data);
    					sharedScope.connection.received(event); 
    				}
    			};
    			this.onSockError = function(event) {
    				log("onSockError"+event.msg);
    				that.socket = null;
    			    that.state=sharedScope.IDLE;
    			    sharedScope.connection.reset(); //use Callback function or Get SIPConnection-Object???
    			  //  that.setProperty("call_state", "idle");
    			    that.hungup();
    			    
    			    $rootScope.$apply();
    			};
    			this.onSockOpen= function() {
    				log("onSockOpen");
    				that.state=sharedScope.CONNECTED;
    			    $rootScope.$apply();
    				
    			};
    			this.onSockClose=function(){
    				log("onSockClose");
    				that.socket = null;
    			    that.state=sharedScope.IDLE;
    			    sharedScope.connection.reset();
    				
    				/*also change register- and callstate*/
    				
    			    $rootScope.$apply();
    			};
    			
    			
    			this.createSocket = function() {
    			    log("createSocket() transport=" + that.transport);
    			    if (true||that.transport == "ws") {
    			        log("  connecting to " + that.outbound_proxy_address);
    			        try {
    			        	that.socket = new WebSocket('ws://' + that.outbound_proxy_address + that.websocket_path, ["sip"]);
    			            that.socket.binaryType = "arraybuffer";
    			            that.socket.onopen = function() { that.onSockOpen(); };
    			            that.socket.onclose = function() {that.onSockClose();};
    			            that.socket.onerror = function(error) { that.onSockError({"code": "websocket-error", "reason": error}); };
    			            that.socket.onmessage = function(msg) { that.onSockData({"data": msg.data, "srcPort": 0, "srcAddress": "127.0.0.1"}); /* src überprüfen*/};
    			        } catch (error) {
    			            log("error in websocket: " + error, "error");
    			            throw error;
    			        }
    			    }
    			    else {
    			        log(that.transport + " transport is not yet implemented", "error");
    			        that.state=sharedScope.IDLE;
//    			        that.setProperty("sock_state", "idle");
//    			        if (that.register_state == "waiting") {
//    			            that.setProperty("register_state", "not registered");
//    			            that.setProperty("register_button", "Register");
//    			            that.setProperty("register_button.disabled", false);
//    			        }
//    			        if (that.call_state == "waiting") {
//    			            that.setProperty("call_state", "idle");
//    			            that.setProperty("call_button.disabled", false);
//    			            that.setProperty("end_button.disabled", true);
//    			        }
    			    }
    			};
    			
    			
    		}

    	return WebSocketService;
    	}
  ]);
});
